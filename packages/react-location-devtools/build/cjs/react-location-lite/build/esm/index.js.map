{"version":3,"file":"index.js","sources":["../../../../../../react-location-lite/build/esm/index.js"],"sourcesContent":["/**\n * react-location-lite\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { createBrowserHistory, createMemoryHistory } from 'history';\nexport { createBrowserHistory, createHashHistory, createMemoryHistory } from 'history';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _excluded = [\"children\", \"location\", \"routes\", \"basepath\"],\n    _excluded2 = [\"to\", \"search\", \"hash\", \"children\", \"target\", \"style\", \"replace\", \"onClick\", \"onMouseEnter\", \"className\", \"getActiveProps\", \"getInactiveProps\", \"activeOptions\", \"disabled\", \"_ref\"],\n    _excluded3 = [\"style\", \"className\"],\n    _excluded4 = [\"style\", \"className\"],\n    _excluded5 = [\"children\"];\n\n// Source\nvar LocationContext = /*#__PURE__*/React.createContext(null);\nvar MatchesContext = /*#__PURE__*/React.createContext(null);\nvar routerContext = /*#__PURE__*/React.createContext(null); // Detect if we're in the DOM\n\nvar isDOM = Boolean(typeof window !== 'undefined' && window.document && window.document.createElement);\nvar useLayoutEffect = isDOM ? React.useLayoutEffect : React.useEffect; // This is the default history object if none is defined\n\nvar createDefaultHistory = function createDefaultHistory() {\n  return isDOM ? createBrowserHistory() : createMemoryHistory();\n};\n\nvar ReactLocation = /*#__PURE__*/function () {\n  //\n  function ReactLocation(options) {\n    var _options$stringifySea,\n        _options$parseSearch,\n        _this = this;\n\n    this.listeners = [];\n    this.isTransitioning = false;\n    this.history = (options == null ? void 0 : options.history) || createDefaultHistory();\n    this.stringifySearch = (_options$stringifySea = options == null ? void 0 : options.stringifySearch) != null ? _options$stringifySea : defaultStringifySearch;\n    this.parseSearch = (_options$parseSearch = options == null ? void 0 : options.parseSearch) != null ? _options$parseSearch : defaultParseSearch;\n    this.current = this.parseLocation(this.history.location);\n    this.destroy = this.history.listen(function (event) {\n      _this.current = _this.parseLocation(event.location, _this.current);\n\n      _this.notify();\n    });\n  }\n\n  var _proto = ReactLocation.prototype;\n\n  _proto.subscribe = function subscribe(listener) {\n    var _this2 = this;\n\n    this.listeners.push(listener);\n    return function () {\n      _this2.listeners = _this2.listeners.filter(function (x) {\n        return x !== listener;\n      });\n    };\n  };\n\n  _proto.notify = function notify() {\n    this.listeners.forEach(function (listener) {\n      return listener();\n    });\n  };\n\n  _proto.buildNext = function buildNext(basepath, dest) {\n    var _dest$to, _ref2, _dest$__searchFilters;\n\n    if (basepath === void 0) {\n      basepath = '/';\n    }\n\n    if (dest === void 0) {\n      dest = {};\n    }\n\n    var from = _extends({}, this.current, dest.from);\n\n    var pathname = resolvePath(basepath, from.pathname, \"\" + ((_dest$to = dest.to) != null ? _dest$to : '.'));\n    var updatedSearch = (_ref2 = dest.search === true ? from.search : functionalUpdate(dest.search, from.search)) != null ? _ref2 : {};\n    var filteredSearch = (_dest$__searchFilters = dest.__searchFilters) != null && _dest$__searchFilters.length ? dest.__searchFilters.reduce(function (prev, next) {\n      return next(prev, updatedSearch);\n    }, from.search) : updatedSearch;\n    var search = replaceEqualDeep(from.search, filteredSearch);\n    var searchStr = this.stringifySearch(search);\n    var hash = functionalUpdate(dest.hash, from.hash);\n    hash = hash ? \"#\" + hash : '';\n    return {\n      pathname: pathname,\n      search: search,\n      searchStr: searchStr,\n      hash: hash,\n      href: \"\" + pathname + searchStr + hash,\n      key: dest.key\n    };\n  };\n\n  _proto.navigate = function navigate(next, replace) {\n    this.current = next;\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout);\n    var nextAction = 'replace';\n\n    if (!replace) {\n      nextAction = 'push';\n    }\n\n    var isSameUrl = this.parseLocation(this.history.location).href === this.current.href;\n\n    if (isSameUrl && !this.current.key) {\n      nextAction = 'replace';\n    }\n\n    if (nextAction === 'replace') {\n      return this.history.replace({\n        pathname: this.current.pathname,\n        hash: this.current.hash,\n        search: this.current.searchStr\n      });\n    }\n\n    return this.history.push({\n      pathname: this.current.pathname,\n      hash: this.current.hash,\n      search: this.current.searchStr\n    }); // }, 16)\n  };\n\n  _proto.parseLocation = function parseLocation(location, previousLocation) {\n    var _location$hash$split$;\n\n    var parsedSearch = this.parseSearch(location.search);\n    return {\n      pathname: location.pathname,\n      searchStr: location.search,\n      search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),\n      hash: (_location$hash$split$ = location.hash.split('#').reverse()[0]) != null ? _location$hash$split$ : '',\n      href: \"\" + location.pathname + location.search + location.hash,\n      key: location.key\n    };\n  };\n\n  return ReactLocation;\n}();\nfunction MatchesProvider(props) {\n  return /*#__PURE__*/React.createElement(MatchesContext.Provider, props);\n}\nfunction Router(_ref3) {\n  var children = _ref3.children,\n      location = _ref3.location,\n      routes = _ref3.routes,\n      userBasepath = _ref3.basepath,\n      rest = _objectWithoutPropertiesLoose(_ref3, _excluded);\n\n  var basepath = cleanPath(\"/\" + (userBasepath != null ? userBasepath : ''));\n\n  var _React$useState = React.useState({\n    location: location.current,\n    matches: []\n  }),\n      routerState = _React$useState[0],\n      setRouterState = _React$useState[1];\n\n  var rootMatch = React.useMemo(function () {\n    return {\n      id: 'root',\n      params: {},\n      search: {},\n      pathname: basepath,\n      route: null\n    };\n  }, [basepath]);\n  var router = React.useMemo(function () {\n    var routesById = {};\n\n    var recurseRoutes = function recurseRoutes(routes, parent) {\n      return routes.map(function (route) {\n        var _route$path, _route$children;\n\n        var path = (_route$path = route.path) != null ? _route$path : '*';\n        var id = joinPaths([(parent == null ? void 0 : parent.id) === 'root' ? '' : parent == null ? void 0 : parent.id, \"\" + (path == null ? void 0 : path.replace(/(.)\\/$/, '$1')) + (route.id ? \"-\" + route.id : '')]);\n        route = _extends({}, route, {\n          id: id\n        });\n\n        if (routesById[id]) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\"Duplicate routes found with id: \" + id, routesById, route);\n          }\n\n          throw new Error();\n        }\n\n        routesById[id] = route;\n        route.children = (_route$children = route.children) != null && _route$children.length ? recurseRoutes(route.children, route) : undefined;\n        return route;\n      });\n    };\n\n    routes = recurseRoutes(routes);\n    return _extends({}, rest, {\n      routesById: routesById,\n      routes: routes,\n      basepath: basepath,\n      rootMatch: rootMatch,\n      state: routerState\n    });\n  }, [routerState, rootMatch, basepath]);\n  console.log(router.state);\n  useLayoutEffect(function () {\n    var update = function update() {\n      var matches = matchRoutes(router, location.current);\n      setRouterState(function () {\n        return {\n          location: location.current,\n          matches: matches\n        };\n      });\n    };\n\n    update();\n    return location.subscribe(update);\n  }, [location.current.key]);\n  return /*#__PURE__*/React.createElement(LocationContext.Provider, {\n    value: {\n      location: location\n    }\n  }, /*#__PURE__*/React.createElement(routerContext.Provider, {\n    value: router\n  }, /*#__PURE__*/React.createElement(MatchesProvider, {\n    value: [router.rootMatch].concat(router.state.matches)\n  }, children != null ? children : /*#__PURE__*/React.createElement(Outlet, null))));\n}\nfunction useLocation() {\n  var context = React.useContext(LocationContext);\n  warning(!!context, 'useLocation must be used within a <ReactLocation />');\n  return context.location;\n}\nfunction useRouter() {\n  var value = React.useContext(routerContext);\n\n  if (!value) {\n    warning(true, 'You are trying to use useRouter() outside of ReactLocation!');\n    throw new Error();\n  }\n\n  return value;\n}\nfunction matchRoutes(router, currentLocation) {\n  if (!router.routes.length) {\n    return [];\n  }\n\n  var matches = [];\n\n  var recurse = function recurse(routes, parentMatch) {\n    var _route$children3;\n\n    var pathname = parentMatch.pathname,\n        params = parentMatch.params;\n    var filteredRoutes = router != null && router.filterRoutes ? router == null ? void 0 : router.filterRoutes(routes) : routes;\n    var route = filteredRoutes.find(function (route) {\n      var _route$children2, _route$caseSensitive;\n\n      var fullRoutePathName = joinPaths([pathname, route.path]);\n      var fuzzy = !!(route.path !== '/' || (_route$children2 = route.children) != null && _route$children2.length);\n      var matchParams = matchRoute(currentLocation, {\n        to: fullRoutePathName,\n        search: route.search,\n        fuzzy: fuzzy,\n        caseSensitive: (_route$caseSensitive = route.caseSensitive) != null ? _route$caseSensitive : router.caseSensitive\n      });\n\n      if (matchParams) {\n        params = _extends({}, params, matchParams);\n      }\n\n      return !!matchParams;\n    });\n\n    if (!route) {\n      return;\n    }\n\n    var interpolatedPath = interpolatePath(route.path, params);\n    pathname = joinPaths([pathname, interpolatedPath]);\n    var interpolatedId = interpolatePath(route.id, params, true);\n    var match = {\n      id: interpolatedId,\n      route: route,\n      params: params,\n      pathname: pathname,\n      search: currentLocation.search\n    };\n    matches.push(match);\n\n    if ((_route$children3 = route.children) != null && _route$children3.length) {\n      recurse(route.children, match);\n    }\n  };\n\n  recurse(router.routes, router.rootMatch);\n  return matches;\n}\n\nfunction interpolatePath(path, params, leaveWildcard) {\n  var interpolatedPathSegments = parsePathname(path);\n  return joinPaths(interpolatedPathSegments.map(function (segment) {\n    if (segment.value === '*' && !leaveWildcard) {\n      return '';\n    }\n\n    if (segment.type === 'param') {\n      var _segment$value$substr;\n\n      return (_segment$value$substr = params[segment.value.substring(1)]) != null ? _segment$value$substr : '';\n    }\n\n    return segment.value;\n  }));\n}\n\nfunction useParentMatches() {\n  var router = useRouter();\n  var match = useMatch();\n  var matches = router.state.matches;\n  return matches.slice(0, matches.findIndex(function (d) {\n    return d.id === match.id;\n  }) - 1);\n}\nfunction useMatches() {\n  return React.useContext(MatchesContext);\n}\nfunction useMatch() {\n  var _useMatches;\n\n  return (_useMatches = useMatches()) == null ? void 0 : _useMatches[0];\n}\nfunction useNavigate() {\n  var location = useLocation();\n  var match = useMatch();\n  var buildNext = useBuildNext();\n\n  function navigate(_ref4) {\n    var _fromCurrent;\n\n    var search = _ref4.search,\n        hash = _ref4.hash,\n        replace = _ref4.replace,\n        from = _ref4.from,\n        to = _ref4.to,\n        fromCurrent = _ref4.fromCurrent;\n    fromCurrent = (_fromCurrent = fromCurrent) != null ? _fromCurrent : typeof to === 'undefined';\n    var next = buildNext({\n      to: to,\n      search: search,\n      hash: hash,\n      from: fromCurrent ? location.current : from != null ? from : {\n        pathname: match.pathname\n      }\n    });\n    location.navigate(next, replace);\n  }\n\n  return useLatestCallback(navigate);\n}\nfunction Navigate(options) {\n  var navigate = useNavigate();\n  useLayoutEffect(function () {\n    navigate(options);\n  }, [navigate]);\n  return null;\n}\n\nfunction useBuildNext() {\n  var location = useLocation();\n  var router = useRouter();\n\n  var buildNext = function buildNext(opts) {\n    var next = location.buildNext(router.basepath, opts);\n    var matches = matchRoutes(router, next);\n\n    var __searchFilters = matches.map(function (match) {\n      var _match$route$searchFi;\n\n      return (_match$route$searchFi = match.route.searchFilters) != null ? _match$route$searchFi : [];\n    }).flat().filter(Boolean);\n\n    return location.buildNext(router.basepath, _extends({}, opts, {\n      __searchFilters: __searchFilters\n    }));\n  };\n\n  return useLatestCallback(buildNext);\n}\n\nvar Link = function Link(_ref5) {\n  var _ref5$to = _ref5.to,\n      to = _ref5$to === void 0 ? '.' : _ref5$to,\n      search = _ref5.search,\n      hash = _ref5.hash,\n      children = _ref5.children,\n      target = _ref5.target,\n      _ref5$style = _ref5.style,\n      style = _ref5$style === void 0 ? {} : _ref5$style,\n      replace = _ref5.replace,\n      onClick = _ref5.onClick;\n      _ref5.onMouseEnter;\n      var _ref5$className = _ref5.className,\n      className = _ref5$className === void 0 ? '' : _ref5$className,\n      _ref5$getActiveProps = _ref5.getActiveProps,\n      getActiveProps = _ref5$getActiveProps === void 0 ? function () {\n    return {};\n  } : _ref5$getActiveProps,\n      _ref5$getInactiveProp = _ref5.getInactiveProps,\n      getInactiveProps = _ref5$getInactiveProp === void 0 ? function () {\n    return {};\n  } : _ref5$getInactiveProp,\n      activeOptions = _ref5.activeOptions,\n      disabled = _ref5.disabled,\n      _ref = _ref5._ref,\n      rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);\n\n  var match = useMatch();\n  var location = useLocation();\n  var navigate = useNavigate();\n  var buildNext = useBuildNext(); // If this `to` is a valid external URL, log a warning\n\n  try {\n    var url = new URL(\"\" + to);\n    warning(false, \"<Link /> should not be used for external URLs like: \" + url.href);\n  } catch (e) {}\n\n  var next = buildNext({\n    to: to,\n    search: search,\n    hash: hash,\n    from: {\n      pathname: match.pathname\n    }\n  }); // The click handler\n\n  var handleClick = function handleClick(e) {\n    if (onClick) onClick(e);\n\n    if (!isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {\n      e.preventDefault(); // All is well? Navigate!\n\n      navigate({\n        to: to,\n        search: search,\n        hash: hash,\n        replace: replace,\n        from: {\n          pathname: match.pathname\n        }\n      });\n    }\n  }; // Compare path/hash for matches\n\n\n  var pathIsEqual = location.current.pathname === next.pathname;\n  var currentPathSplit = location.current.pathname.split('/');\n  var nextPathSplit = next.pathname.split('/');\n  var pathIsFuzzyEqual = nextPathSplit.every(function (d, i) {\n    return d === currentPathSplit[i];\n  });\n  var hashIsEqual = location.current.hash === next.hash; // Combine the matches based on user options\n\n  var pathTest = activeOptions != null && activeOptions.exact ? pathIsEqual : pathIsFuzzyEqual;\n  var hashTest = activeOptions != null && activeOptions.includeHash ? hashIsEqual : true; // The final \"active\" test\n\n  var isActive = pathTest && hashTest; // Get the active props\n\n  var _ref6 = isActive ? getActiveProps() : {},\n      _ref6$style = _ref6.style,\n      activeStyle = _ref6$style === void 0 ? {} : _ref6$style,\n      _ref6$className = _ref6.className,\n      activeClassName = _ref6$className === void 0 ? '' : _ref6$className,\n      activeRest = _objectWithoutPropertiesLoose(_ref6, _excluded3); // Get the inactive props\n\n\n  var _ref7 = isActive ? {} : getInactiveProps(),\n      _ref7$style = _ref7.style,\n      inactiveStyle = _ref7$style === void 0 ? {} : _ref7$style,\n      _ref7$className = _ref7.className,\n      inactiveClassName = _ref7$className === void 0 ? '' : _ref7$className,\n      inactiveRest = _objectWithoutPropertiesLoose(_ref7, _excluded4);\n\n  return /*#__PURE__*/React.createElement(\"a\", _extends({\n    ref: _ref,\n    href: disabled ? undefined : next.href,\n    onClick: handleClick,\n    target: target,\n    style: _extends({}, style, activeStyle, inactiveStyle),\n    className: [className, activeClassName, inactiveClassName].filter(Boolean).join(' ') || undefined\n  }, disabled ? {\n    role: 'link',\n    'aria-disabled': true\n  } : undefined, rest, activeRest, inactiveRest, {\n    children: typeof children === 'function' ? children({\n      isActive: isActive\n    }) : children\n  }));\n};\nfunction Outlet() {\n  var _match$route$element, _match$route$pendingE;\n\n  var router = useRouter();\n\n  var _useMatches2 = useMatches();\n      _useMatches2[0];\n      var matches = _useMatches2.slice(1);\n\n  var match = matches[0];\n\n  if (!match) {\n    return null;\n  }\n\n  var matchElement = (_match$route$element = match.route.element) != null ? _match$route$element : router.defaultElement;\n  var element = /*#__PURE__*/React.createElement(MatchesProvider, {\n    value: matches\n  }, matchElement != null ? matchElement : /*#__PURE__*/React.createElement(Outlet, null));\n  var pendingElement = (_match$route$pendingE = match.route.pendingElement) != null ? _match$route$pendingE : router.defaultPendingElement;\n\n  if (pendingElement) {\n    return /*#__PURE__*/React.createElement(React.Suspense, {\n      fallback: pendingElement\n    }, element);\n  }\n\n  return element;\n}\nfunction useResolvePath() {\n  var router = useRouter();\n  var match = useMatch();\n  return useLatestCallback(function (path) {\n    return resolvePath(router.basepath, match.pathname, cleanPath(path));\n  });\n}\nfunction useSearch() {\n  var location = useLocation();\n  return location.current.search;\n}\nfunction matchRoute(currentLocation, matchLocation) {\n  var pathParams = matchByPath(currentLocation, matchLocation);\n  var searchMatched = matchBySearch(currentLocation, matchLocation);\n\n  if (matchLocation.to && !pathParams) {\n    return;\n  }\n\n  if (matchLocation.search && !searchMatched) {\n    return;\n  }\n\n  return pathParams != null ? pathParams : {};\n}\nfunction useMatchRoute() {\n  var router = useRouter();\n  var resolvePath = useResolvePath();\n  return useLatestCallback(function (matchLocation) {\n    matchLocation = _extends({}, matchLocation, {\n      to: matchLocation.to ? resolvePath(\"\" + matchLocation.to) : undefined\n    });\n    return matchRoute(router.state.location, matchLocation);\n  });\n}\nfunction MatchRoute(_ref8) {\n  var children = _ref8.children,\n      rest = _objectWithoutPropertiesLoose(_ref8, _excluded5);\n\n  var matchRoute = useMatchRoute();\n  var match = matchRoute(rest);\n\n  if (typeof children === 'function') {\n    return children(match);\n  }\n\n  return match ? children : null;\n}\nfunction usePrompt(message, when) {\n  var location = useLocation();\n  React.useEffect(function () {\n    if (!when) return;\n    var unblock = location.history.block(function (transition) {\n      if (window.confirm(message)) {\n        unblock();\n        transition.retry();\n      } else {\n        location.current.pathname = window.location.pathname;\n      }\n    });\n    return unblock;\n  }, [when, location, message]);\n}\nfunction Prompt(_ref9) {\n  var message = _ref9.message,\n      when = _ref9.when,\n      children = _ref9.children;\n  usePrompt(message, when != null ? when : true);\n  return children != null ? children : null;\n}\n\nfunction warning(cond, message) {\n  if (!cond) {\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      throw new Error(message);\n    } catch (_unused) {}\n  }\n}\n\nfunction isFunction(d) {\n  return typeof d === 'function';\n}\n\nfunction functionalUpdate(updater, previous) {\n  if (isFunction(updater)) {\n    return updater(previous);\n  }\n\n  return updater;\n}\n\nfunction joinPaths(paths) {\n  return cleanPath(paths.filter(Boolean).join('/'));\n}\n\nfunction cleanPath(path) {\n  // remove double slashes\n  return (\"\" + path).replace(/\\/{2,}/g, '/');\n}\nfunction matchByPath(currentLocation, matchLocation) {\n  var _matchLocation$to;\n\n  var baseSegments = parsePathname(currentLocation.pathname);\n  var routeSegments = parsePathname(\"\" + ((_matchLocation$to = matchLocation.to) != null ? _matchLocation$to : '*'));\n  var params = {};\n\n  var isMatch = function () {\n    for (var i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {\n      var baseSegment = baseSegments[i];\n      var routeSegment = routeSegments[i];\n      var isLastRouteSegment = i === routeSegments.length - 1;\n      var isLastBaseSegment = i === baseSegments.length - 1;\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment != null && baseSegment.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map(function (d) {\n              return d.value;\n            }));\n            return true;\n          }\n\n          return false;\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !(baseSegment != null && baseSegment.value)) {\n            return true;\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false;\n              }\n            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {\n              return false;\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false;\n        }\n\n        if (routeSegment.type === 'param') {\n          params[routeSegment.value.substring(1)] = baseSegment.value;\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy;\n      }\n    }\n\n    return true;\n  }();\n\n  return isMatch ? params : undefined;\n}\n\nfunction matchBySearch(currentLocation, matchLocation) {\n  return !!(matchLocation.search && matchLocation.search(currentLocation.search));\n}\n\nfunction parsePathname(pathname) {\n  if (!pathname) {\n    return [];\n  }\n\n  pathname = cleanPath(pathname);\n  var segments = [];\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n\n  if (!pathname) {\n    return segments;\n  } // Remove empty segments and '.' segments\n\n\n  var split = pathname.split('/').filter(Boolean);\n  segments.push.apply(segments, split.map(function (part) {\n    if (part.startsWith('*')) {\n      return {\n        type: 'wildcard',\n        value: part\n      };\n    }\n\n    if (part.charAt(0) === ':') {\n      return {\n        type: 'param',\n        value: part\n      };\n    }\n\n    return {\n      type: 'pathname',\n      value: part\n    };\n  }));\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n\n  return segments;\n}\nfunction resolvePath(basepath, base, to) {\n  base = base.replace(new RegExp(\"^\" + basepath), '/');\n  to = to.replace(new RegExp(\"^\" + basepath), '/');\n  var baseSegments = parsePathname(base);\n  var toSegments = parsePathname(to);\n  toSegments.forEach(function (toSegment, index) {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment];\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment);\n      } else ;\n    } else if (toSegment.value === '..') {\n      baseSegments.pop();\n    } else if (toSegment.value === '.') {\n      return;\n    } else {\n      baseSegments.push(toSegment);\n    }\n  });\n  var joined = joinPaths([basepath].concat(baseSegments.map(function (d) {\n    return d.value;\n  })));\n  return cleanPath(joined);\n}\n\nfunction isCtrlEvent(e) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n}\n\nfunction useLatestCallback(cb) {\n  var stableFnRef = React.useRef();\n  var cbRef = React.useRef(cb);\n  cbRef.current = cb;\n\n  if (!stableFnRef.current) {\n    stableFnRef.current = function () {\n      return cbRef.current.apply(cbRef, arguments);\n    };\n  }\n\n  return stableFnRef.current;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\n\nfunction replaceEqualDeep(prev, next) {\n  if (prev === next) {\n    return prev;\n  }\n\n  var array = Array.isArray(prev) && Array.isArray(next);\n\n  if (array || isPlainObject(prev) && isPlainObject(next)) {\n    var aSize = array ? prev.length : Object.keys(prev).length;\n    var bItems = array ? next : Object.keys(next);\n    var bSize = bItems.length;\n    var copy = array ? [] : {};\n    var equalItems = 0;\n\n    for (var i = 0; i < bSize; i++) {\n      var key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(prev[key], next[key]);\n\n      if (copy[key] === prev[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? prev : copy;\n  }\n\n  return next;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  var ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  var prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction defaultStringifySearch(search) {\n  search = _extends({}, search);\n\n  if (search) {\n    Object.keys(search).forEach(function (key) {\n      var val = search[key];\n\n      if (typeof val === 'undefined' || val === undefined) {\n        delete search[key];\n      } else if (val && typeof val === 'object' && val !== null) {\n        try {\n          search[key] = JSON.stringify(val);\n        } catch (err) {// silent\n        }\n      }\n    });\n  }\n\n  var searchStr = new URLSearchParams(search).toString();\n  return searchStr ? \"?\" + searchStr : '';\n}\nfunction defaultParseSearch(searchStr) {\n  if (searchStr.substring(0, 1) === '?') {\n    searchStr = searchStr.substring(1);\n  }\n\n  var query = Object.fromEntries(new URLSearchParams(searchStr).entries()); // Try to parse query params\n\n  for (var key in query) {\n    var value = query[key];\n\n    try {\n      query[key] = JSON.parse(value);\n    } catch (err) {//\n    }\n  }\n\n  return query;\n}\n\nexport { Link, MatchRoute, MatchesProvider, Navigate, Outlet, Prompt, ReactLocation, Router, cleanPath, defaultParseSearch, defaultStringifySearch, functionalUpdate, matchByPath, matchRoute, matchRoutes, parsePathname, resolvePath, useLocation, useMatch, useMatchRoute, useMatches, useNavigate, useParentMatches, usePrompt, useResolvePath, useRouter, useSearch };\n//# sourceMappingURL=index.js.map\n"],"names":["React"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA+CA,IAAI,aAAa,gBAAgBA,gBAAK,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;AA4N3D,SAAS,SAAS,GAAG;AACrB,EAAE,IAAI,KAAK,GAAGA,gBAAK,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AAC9C;AACA,EAAE,IAAI,CAAC,KAAK,EAAE;AACd,IAAI,OAAO,CAAC,IAAI,EAAE,6DAA6D,CAAC,CAAC;AACjF,IAAI,MAAM,IAAI,KAAK,EAAE,CAAC;AACtB,GAAG;AACH;AACA,EAAE,OAAO,KAAK,CAAC;AACf,CAAC;AAqWD;AACA,SAAS,OAAO,CAAC,IAAI,EAAE,OAAO,EAAE;AAChC,EAAE,IAAI,CAAC,IAAI,EAAE;AACb,IAAI,IAAI,OAAO,OAAO,KAAK,WAAW,EAAE,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC9D;AACA,IAAI,IAAI;AACR,MAAM,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;AAC/B,KAAK,CAAC,OAAO,OAAO,EAAE,EAAE;AACxB,GAAG;AACH;;;;;;;;;;;;;;;;"}