{"version":3,"file":"index.production.js","sources":["../../src/jsurl.ts","../../src/qss.ts","../../src/index.tsx"],"sourcesContent":["// We're inlining our own version of qss here for compression's sake, but we've included it as a hard dependency for the MIT license it requires.\n// Types are naive, but at least it compiles!\n\n// Unreserved characters for URL encoding are: - . _ ~\n// Earlier versions of this library used a different encoding for strings, but in our version we use a period for the string delimiter.\nconst previousStringPrefixes = [\"'\"] as const\nconst stringPrefix = '-'\n\nexport function stringify(v: any): string {\n  function encode(s: any) {\n    return !/[^\\w-.]/.test(s)\n      ? s\n      : s.replace(/[^\\w-.]/g, function (ch: any) {\n          if (ch === '$') return '!'\n          ch = ch.charCodeAt(0)\n          // thanks to Douglas Crockford for the negative slice trick\n          return ch < 0x100\n            ? '*' + ('00' + ch.toString(16)).slice(-2)\n            : '**' + ('0000' + ch.toString(16)).slice(-4)\n        })\n  }\n\n  var tmpAry\n\n  switch (typeof v) {\n    case 'number':\n      return isFinite(v) ? '~' + v : '~null'\n    case 'boolean':\n      return '~' + v\n    case 'string':\n      return '~' + stringPrefix + encode(v)\n    case 'object':\n      if (!v) return '~null'\n\n      tmpAry = []\n\n      if (Array.isArray(v)) {\n        for (var i = 0; i < v.length; i++) {\n          tmpAry[i] = stringify(v[i]!) || '~null'\n        }\n\n        return '~(' + (tmpAry.join('') || '~') + ')'\n      } else {\n        for (var key in v) {\n          if (v.hasOwnProperty(key)) {\n            var val = stringify(v[key]!)\n\n            // skip undefined and functions\n            if (val) {\n              tmpAry.push(encode(key) + val)\n            }\n          }\n        }\n\n        return '~(' + tmpAry.join('~') + ')'\n      }\n    default:\n      // function, undefined\n      return ''\n  }\n}\n\nvar reserved: Record<string, boolean | null> = {\n  true: true,\n  false: false,\n  null: null,\n} as const\n\nexport function parse(s: string): unknown {\n  if (!s) return s\n  s = s.replace(/%(25)*27/g, \"'\")\n  var i = 0,\n    len = s.length\n\n  function eat(expected: any) {\n    if (s.charAt(i) !== expected) {\n      // throw new Error(\n      //   'bad JSURL syntax: expected ' +\n      //     expected +\n      //     ', got ' +\n      //     (s && s.charAt(i)),\n      // )\n      throw new Error()\n    }\n    i++\n  }\n\n  function decode() {\n    var beg = i,\n      ch,\n      r = ''\n    while (i < len && (ch = s.charAt(i)) !== '~' && ch !== ')') {\n      switch (ch) {\n        case '*':\n          if (beg < i) r += s.substring(beg, i)\n          if (s.charAt(i + 1) === '*')\n            (r += String.fromCharCode(parseInt(s.substring(i + 2, i + 6), 16))),\n              (beg = i += 6)\n          else\n            (r += String.fromCharCode(parseInt(s.substring(i + 1, i + 3), 16))),\n              (beg = i += 3)\n          break\n        case '!':\n          if (beg < i) r += s.substring(beg, i)\n          ;(r += '$'), (beg = ++i)\n          break\n        default:\n          i++\n      }\n    }\n    return r + s.substring(beg, i)\n  }\n\n  return (function parseOne(): any {\n    var result: any, ch, beg\n    eat('~')\n    const current = (ch = s.charAt(i))\n    if (current === '(') {\n      i++\n      if (s.charAt(i) === '~') {\n        result = []\n        if (s.charAt(i + 1) === ')') i++\n        else {\n          do {\n            result.push(parseOne())\n          } while (s.charAt(i) === '~')\n        }\n      } else {\n        result = {}\n        if (s.charAt(i) !== ')') {\n          do {\n            var key = decode()\n            result[key] = parseOne()\n          } while (s.charAt(i) === '~' && ++i)\n        }\n      }\n      eat(')')\n    } else if ([stringPrefix, ...previousStringPrefixes].includes(current)) {\n      i++\n      result = decode()\n    } else {\n      beg = i++\n      while (i < len && /[^)~]/.test(s.charAt(i))) i++\n      var sub: string = s.substring(beg, i)\n      if (/[\\d\\-]/.test(ch)) {\n        result = parseFloat(sub)\n      } else {\n        result = reserved[sub]\n        if (typeof result === 'undefined') {\n          // throw new Error('bad value keyword: ' + sub)\n          throw new Error()\n        }\n      }\n    }\n    return result\n  })()\n}\n\nexport function tryParse<T>(s: string, def: any): unknown | T {\n  try {\n    return parse(s)\n  } catch (ex) {\n    return def\n  }\n}\n","// @ts-nocheck\n\n// We're inlining qss here for compression's sake, but we've included it as a hard dependency for the MIT license it requires.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","import { stringify, parse } from './jsurl'\nimport { decode, encode } from './qss'\n\nexport function stringifySearch(search: Record<string, unknown>) {\n  search = { ...search }\n\n  if (search) {\n    Object.keys(search).forEach((key) => {\n      const val = search[key]\n      if (typeof val === 'undefined' || val === undefined) {\n        delete search[key]\n      } else if (val && typeof val === 'object' && val !== null) {\n        try {\n          search[key] = stringify(val)\n        } catch (err) {\n          // silent\n        }\n      }\n    })\n  }\n\n  const searchStr = encode(search as Record<string, string>).toString()\n\n  return searchStr ? `?${searchStr}` : ''\n}\n\nexport function parseSearch(searchStr: string): Record<string, any> {\n  if (searchStr.substring(0, 1) === '?') {\n    searchStr = searchStr.substring(1)\n  }\n\n  let query: Record<string, unknown> = decode(searchStr)\n\n  // Try to parse any query params that might be json\n  for (let key in query) {\n    const value = query[key]\n    if (typeof value === 'string') {\n      try {\n        query[key] = parse(value)\n      } catch (err) {\n        //\n      }\n    }\n  }\n\n  return query\n}\n"],"names":["previousStringPrefixes","stringPrefix","stringify","v","encode","s","test","replace","ch","charCodeAt","toString","slice","tmpAry","isFinite","Array","isArray","i","length","join","key","hasOwnProperty","val","push","reserved","parse","len","eat","expected","charAt","Error","decode","beg","r","substring","String","fromCharCode","parseInt","parseOne","result","current","includes","sub","parseFloat","toValue","mix","str","decodeURIComponent","searchStr","query","tmp","k","out","arr","split","shift","concat","value","err","search","Object","keys","forEach","undefined","obj","pfx","encodeURIComponent"],"mappings":"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"}