{"version":3,"file":"index.production.js","sources":["../../src/index.tsx"],"sourcesContent":["import * as React from 'react'\n\nimport {\n  createHashHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n  BrowserHistory,\n  MemoryHistory,\n  History,\n  HashHistory,\n} from 'history'\n\nexport { createHashHistory, createBrowserHistory, createMemoryHistory }\n\n// Types\n\ntype Timeout = ReturnType<typeof setTimeout>\n\ntype Maybe<T, TUnknown> = T extends {} ? T : TUnknown\n\nexport type DefaultGenerics = {\n  Params: Params<string>\n  Search: Search<unknown>\n  RouteMeta: RouteMeta<unknown>\n}\n\nexport type PartialGenerics = Partial<DefaultGenerics>\nexport type MakeGenerics<TGenerics extends PartialGenerics> = TGenerics\n\nexport type Search<T> = Record<string, T>\nexport type Params<T> = Record<string, T>\nexport type RouteMeta<T> = Record<string, T>\n\nexport type UseGeneric<\n  TGenerics extends PartialGenerics,\n  TGeneric extends keyof PartialGenerics,\n> = TGeneric extends 'Search'\n  ? Partial<Maybe<TGenerics[TGeneric], DefaultGenerics[TGeneric]>>\n  : Maybe<TGenerics[TGeneric], DefaultGenerics[TGeneric]>\n\nexport type ReactLocationOptions = {\n  // The history object to be used internally by react-location\n  // A history will be created automatically if not provided.\n  history?: BrowserHistory | MemoryHistory | HashHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n}\n\ntype SearchSerializer = (searchObj: Record<string, any>) => string\ntype SearchParser = (searchStr: string) => Record<string, any>\n\nexport type Updater<TResult> = TResult | ((prev?: TResult) => TResult)\n\nexport type Location<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  href: string\n  pathname: string\n  search: UseGeneric<TGenerics, 'Search'>\n  searchStr: string\n  hash: string\n  key?: string\n  // nextAction?: 'push' | 'replace'\n}\n\nexport type Route<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  // The path to match (relative to the nearest parent `Route` component or root basepath)\n  path?: string\n  // An ID to uniquely identify this route within its siblings. This is only required for routes that *only match on search* or if you have multiple routes with the same path\n  id?: string\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // Either (1) an object that will be used to shallowly match the current location's search or (2) A function that receives the current search params and can return truthy if they are matched.\n  search?: SearchPredicate<UseGeneric<TGenerics, 'Search'>>\n  // The duration to wait during `loader` execution before showing the `pendingElement`\n  searchFilters?: SearchFilter<TGenerics>[]\n  // An array of child routes\n  children?: Route<TGenerics>[]\n  // Route Loaders (see below) can be inline on the route, or resolved async\n  pendingElement?: React.ReactNode\n} & RouteLoaders<TGenerics>\n\nexport type RouteLoaders<TGenerics> = {\n  // The content to be rendered when the route is matched. If no element is provided, defaults to `<Outlet />`\n  element?: React.ReactNode\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  // An object of whatever you want! This object is accessible anywhere matches are.\n  meta?: UseGeneric<TGenerics, 'RouteMeta'>\n}\n\nexport type SearchFilter<TGenerics> = (\n  prev: UseGeneric<TGenerics, 'Search'>,\n  next: UseGeneric<TGenerics, 'Search'>,\n) => UseGeneric<TGenerics, 'Search'>\n\nexport type MatchLocation<TGenerics extends PartialGenerics = DefaultGenerics> =\n  {\n    to?: string | number | null\n    search?: SearchPredicate<UseGeneric<TGenerics, 'Search'>>\n    fuzzy?: boolean\n    caseSensitive?: boolean\n  }\n\nexport type SearchPredicate<TSearch> = (search: TSearch) => any\n\nexport type ListenerFn = () => void\n\nexport type Segment = {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport type RouterProps<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  // Children will default to `<Outlet />` if not provided\n  children?: React.ReactNode\n  location: ReactLocation<TGenerics>\n} & RouterOptions<TGenerics>\n\nexport type RouterOptions<TGenerics> = {\n  // An array of route objects to match\n  routes: Route<TGenerics>[]\n  basepath?: string\n  filterRoutes?: FilterRoutesFn\n  useErrorBoundary?: boolean\n  defaultElement?: React.ReactNode\n  defaultPendingElement?: React.ReactNode\n  caseSensitive?: boolean\n  // An array of route match objects that have been both _matched_ and _loaded_. See the [SRR](#ssr) section for more details\n  // snapshot?: RouterSnapshot<TGenerics>\n}\n\nexport type BuildNextOptions<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = {\n  to?: string | number | null\n  search?: true | Updater<UseGeneric<TGenerics, 'Search'>>\n  hash?: Updater<string>\n  from?: Partial<Location<TGenerics>>\n  key?: string\n  __searchFilters?: SearchFilter<TGenerics>[]\n}\n\nexport type NavigateOptions<TGenerics> = BuildNextOptions<TGenerics> & {\n  replace?: boolean\n  fromCurrent?: boolean\n}\n\nexport type PromptProps = {\n  message: string\n  when?: boolean | any\n  children?: React.ReactNode\n}\n\nexport type LinkProps<TGenerics extends PartialGenerics = DefaultGenerics> =\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'href' | 'children'> & {\n    // The absolute or relative destination pathname\n    to?: string | number | null\n    // The new search object or a function to update it\n    search?: true | Updater<UseGeneric<TGenerics, 'Search'>>\n    // The new has string or a function to update it\n    hash?: Updater<string>\n    // Whether to replace the current history stack instead of pushing a new one\n    replace?: boolean\n    // A function that is passed the [Location API](#location-api) and returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n    getActiveProps?: () => Record<string, any>\n    // A function that is passed the [Location API](#location-api) and returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n    getInactiveProps?: () => Record<string, any>\n    // Defaults to `{ exact: false, includeHash: false }`\n    activeOptions?: ActiveOptions\n    // If true, will render the link without the href attribute\n    disabled?: boolean\n    // A custom ref prop because of this: https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref/58473012\n    _ref?: React.Ref<HTMLAnchorElement>\n    // If a function is pass as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\ntype ActiveOptions = {\n  exact?: boolean\n  includeHash?: boolean\n}\n\nexport type LinkPropsType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  LinkProps<TGenerics>\n\nexport type TransitionState<TGenerics> = {\n  location: Location<TGenerics>\n  matches: RouteMatch<TGenerics>[]\n}\n\nexport type FilterRoutesFn = <\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  routes: Route<TGenerics>[],\n) => Route<TGenerics>[]\n\nexport type RouterPropsType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = RouterProps<TGenerics>\n\nexport type RouterType<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  props: RouterProps<TGenerics>,\n) => JSX.Element\n\ntype Listener = () => void\n\n// Source\n\nconst LocationContext = React.createContext<{ location: ReactLocation<any> }>(\n  null!,\n)\nconst MatchesContext = React.createContext<RouteMatch<any>[]>(null!)\nconst routerContext = React.createContext<\n  RouterInstance<any> & { state: TransitionState<any> }\n>(null!)\n\n// Detect if we're in the DOM\nconst isDOM = Boolean(\n  typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement,\n)\n\nconst useLayoutEffect = isDOM ? React.useLayoutEffect : React.useEffect\n\n// This is the default history object if none is defined\nconst createDefaultHistory = () =>\n  isDOM ? createBrowserHistory() : createMemoryHistory()\n\nexport class ReactLocation<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> {\n  history: BrowserHistory | MemoryHistory\n  stringifySearch: SearchSerializer\n  parseSearch: SearchParser\n\n  current: Location<TGenerics>\n  destroy: () => void\n  navigateTimeout?: Timeout\n  nextAction?: 'push' | 'replace'\n\n  //\n\n  listeners: Listener[] = []\n  isTransitioning: boolean = false\n\n  constructor(options?: ReactLocationOptions) {\n    this.history = options?.history || createDefaultHistory()\n    this.stringifySearch = options?.stringifySearch ?? defaultStringifySearch\n    this.parseSearch = options?.parseSearch ?? defaultParseSearch\n\n    this.current = this.parseLocation(this.history.location)\n\n    this.destroy = this.history.listen((event) => {\n      this.current = this.parseLocation(event.location, this.current)\n      this.notify()\n    })\n  }\n\n  subscribe(listener: Listener): () => void {\n    this.listeners.push(listener as Listener)\n\n    return () => {\n      this.listeners = this.listeners.filter((x) => x !== listener)\n    }\n  }\n\n  notify(): void {\n    this.listeners.forEach((listener) => listener())\n  }\n\n  buildNext(\n    basepath: string = '/',\n    dest: BuildNextOptions<TGenerics> = {},\n  ): Location<TGenerics> {\n    const from = {\n      ...this.current,\n      ...dest.from,\n    }\n\n    const pathname = resolvePath(basepath, from.pathname, `${dest.to ?? '.'}`)\n\n    const updatedSearch =\n      (dest.search === true\n        ? from.search\n        : functionalUpdate(dest.search, from.search)) ?? {}\n\n    const filteredSearch = dest.__searchFilters?.length\n      ? dest.__searchFilters.reduce(\n          (prev, next) => next(prev, updatedSearch),\n          from.search,\n        )\n      : updatedSearch\n\n    const search = replaceEqualDeep(from.search, filteredSearch)\n\n    const searchStr = this.stringifySearch(search)\n    let hash = functionalUpdate(dest.hash, from.hash)\n    hash = hash ? `#${hash}` : ''\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      hash,\n      href: `${pathname}${searchStr}${hash}`,\n      key: dest.key,\n    }\n  }\n\n  navigate(next: Location<TGenerics>, replace?: boolean): void {\n    this.current = next\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl =\n      this.parseLocation(this.history.location).href === this.current.href\n\n    if (isSameUrl && !this.current.key) {\n      nextAction = 'replace'\n    }\n\n    if (nextAction === 'replace') {\n      return this.history.replace({\n        pathname: this.current.pathname,\n        hash: this.current.hash,\n        search: this.current.searchStr,\n      })\n    }\n\n    return this.history.push({\n      pathname: this.current.pathname,\n      hash: this.current.hash,\n      search: this.current.searchStr,\n    })\n    // }, 16)\n  }\n\n  parseLocation(\n    location: History['location'],\n    previousLocation?: Location<TGenerics>,\n  ): Location<TGenerics> {\n    const parsedSearch = this.parseSearch(location.search)\n\n    return {\n      pathname: location.pathname,\n      searchStr: location.search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: location.hash.split('#').reverse()[0] ?? '',\n      href: `${location.pathname}${location.search}${location.hash}`,\n      key: location.key,\n    }\n  }\n}\n\nexport type MatchesProviderProps<TGenerics> = {\n  value: RouteMatch<TGenerics>[]\n  children: React.ReactNode\n}\n\nexport function MatchesProvider<TGenerics>(\n  props: MatchesProviderProps<TGenerics>,\n) {\n  return <MatchesContext.Provider {...props} />\n}\n\nexport type RouterInstance<TGenerics> = {\n  routesById: Record<string, Route<TGenerics>>\n  basepath: string\n  rootMatch?: RouteMatch<TGenerics>\n  routes: Route<TGenerics>[]\n  filterRoutes?: FilterRoutesFn\n  useErrorBoundary?: boolean\n  defaultElement?: React.ReactNode\n  defaultPendingElement?: React.ReactNode\n  caseSensitive?: boolean\n  state: TransitionState<TGenerics>\n}\n\nexport function Router<TGenerics extends PartialGenerics = DefaultGenerics>({\n  children,\n  location,\n  routes,\n  basepath: userBasepath,\n  // snapshot,\n  ...rest\n}: RouterProps<TGenerics>) {\n  const basepath = cleanPath(`/${userBasepath ?? ''}`)\n\n  const [routerState, setRouterState] = React.useState<\n    TransitionState<TGenerics>\n  >({\n    location: location.current,\n    matches: [],\n  })\n\n  const rootMatch = React.useMemo(\n    () => ({\n      id: 'root',\n      params: {} as any,\n      search: {} as any,\n      pathname: basepath,\n      route: null!,\n    }),\n    [basepath],\n  )\n\n  const router: RouterInstance<TGenerics> = React.useMemo(() => {\n    const routesById: RouterInstance<TGenerics>['routesById'] = {}\n\n    const recurseRoutes = (\n      routes: Route<TGenerics>[],\n      parent?: Route<TGenerics>,\n    ): Route<TGenerics>[] => {\n      return routes.map((route) => {\n        const path = route.path ?? '*'\n\n        const id = joinPaths([\n          parent?.id === 'root' ? '' : parent?.id,\n          `${path?.replace(/(.)\\/$/, '$1')}${route.id ? `-${route.id}` : ''}`,\n        ])\n\n        route = {\n          ...route,\n          id,\n        }\n\n        if (routesById[id]) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `Duplicate routes found with id: ${id}`,\n              routesById,\n              route,\n            )\n          }\n          throw new Error()\n        }\n\n        routesById[id] = route\n\n        route.children = route.children?.length\n          ? recurseRoutes(route.children, route)\n          : undefined\n\n        return route\n      })\n    }\n\n    routes = recurseRoutes(routes)\n\n    return {\n      ...rest,\n      routesById,\n      routes,\n      basepath,\n      rootMatch,\n      state: routerState,\n    }\n  }, [routerState, rootMatch, basepath])\n\n  console.log(router.state)\n\n  useLayoutEffect(() => {\n    const update = () => {\n      const matches = matchRoutes(router, location.current)\n\n      setRouterState(() => {\n        return {\n          location: location.current,\n          matches: matches,\n        }\n      })\n    }\n\n    update()\n\n    return location.subscribe(update)\n  }, [location.current.key])\n\n  return (\n    <LocationContext.Provider value={{ location }}>\n      <routerContext.Provider value={router}>\n        <MatchesProvider value={[router.rootMatch!, ...router.state.matches]}>\n          {children ?? <Outlet />}\n        </MatchesProvider>\n      </routerContext.Provider>\n    </LocationContext.Provider>\n  )\n}\n\nexport type UseLocationType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => ReactLocation<TGenerics>\n\nexport function useLocation<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): ReactLocation<TGenerics> {\n  const context = React.useContext(LocationContext) as {\n    location: ReactLocation<TGenerics>\n  }\n  warning(!!context, 'useLocation must be used within a <ReactLocation />')\n\n  return context.location\n}\n\ntype RouteMatch<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  id: string\n  route: Route<TGenerics>\n  pathname: string\n  params: UseGeneric<TGenerics, 'Params'>\n  search: UseGeneric<TGenerics, 'Search'>\n}\n\nexport type UseRouterType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => RouterInstance<TGenerics>\n\nexport function useRouter<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouterInstance<TGenerics> {\n  const value = React.useContext(routerContext)\n  if (!value) {\n    warning(true, 'You are trying to use useRouter() outside of ReactLocation!')\n    throw new Error()\n  }\n\n  return value as RouterInstance<TGenerics>\n}\n\nexport type MatchRoutesType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (\n  router: RouterInstance<TGenerics>[],\n  currentLocation: Location<TGenerics>,\n) => Promise<RouteMatch<TGenerics>[]>\n\nexport function matchRoutes<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  router: RouterInstance<TGenerics>,\n  currentLocation: Location<TGenerics>,\n): RouteMatch<TGenerics>[] {\n  if (!router.routes.length) {\n    return []\n  }\n\n  const matches: RouteMatch<TGenerics>[] = []\n\n  const recurse = (\n    routes: Route<TGenerics>[],\n    parentMatch: RouteMatch<TGenerics>,\n  ) => {\n    let { pathname, params } = parentMatch\n    const filteredRoutes = router?.filterRoutes\n      ? router?.filterRoutes(routes)\n      : routes\n\n    const route = filteredRoutes.find((route) => {\n      const fullRoutePathName = joinPaths([pathname, route.path])\n\n      const fuzzy = !!(route.path !== '/' || route.children?.length)\n\n      const matchParams = matchRoute(currentLocation, {\n        to: fullRoutePathName,\n        search: route.search,\n        fuzzy,\n        caseSensitive: route.caseSensitive ?? router.caseSensitive,\n      })\n\n      if (matchParams) {\n        params = {\n          ...params,\n          ...matchParams,\n        }\n      }\n\n      return !!matchParams\n    })\n\n    if (!route) {\n      return\n    }\n\n    const interpolatedPath = interpolatePath(route.path, params)\n    pathname = joinPaths([pathname, interpolatedPath])\n\n    const interpolatedId = interpolatePath(route.id, params, true)\n\n    const match: RouteMatch<TGenerics> = {\n      id: interpolatedId,\n      route,\n      params,\n      pathname,\n      search: currentLocation.search,\n    }\n\n    matches.push(match)\n\n    if (route.children?.length) {\n      recurse(route.children, match)\n    }\n  }\n\n  recurse(router.routes, router.rootMatch!)\n\n  return matches\n}\n\nfunction interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcard?: boolean,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.value === '*' && !leaveWildcard) {\n        return ''\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport type UseMatchesType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => RouteMatch<TGenerics>[]\n\nexport function useParentMatches<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics>[] {\n  const router = useRouter<TGenerics>()\n  const match = useMatch()\n\n  const matches = router.state.matches\n\n  return matches.slice(0, matches.findIndex((d) => d.id === match.id) - 1)\n}\n\nexport function useMatches<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics>[] {\n  return React.useContext(MatchesContext)\n}\n\nexport type UseMatchType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => RouteMatch<TGenerics>\n\nexport function useMatch<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics> {\n  return useMatches<TGenerics>()?.[0]!\n}\n\nexport type UseNavigateType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (options: NavigateOptions<TGenerics>) => void\n\nexport function useNavigate<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  function navigate({\n    search,\n    hash,\n    replace,\n    from,\n    to,\n    fromCurrent,\n  }: NavigateOptions<TGenerics> & {\n    replace?: boolean\n  }) {\n    fromCurrent = fromCurrent ?? typeof to === 'undefined'\n\n    const next = buildNext({\n      to,\n      search,\n      hash,\n      from: fromCurrent\n        ? location.current\n        : from ?? { pathname: match.pathname },\n    })\n\n    location.navigate(next, replace)\n  }\n\n  return useLatestCallback(navigate)\n}\n\nexport type NavigateType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  (options: NavigateOptions<TGenerics>) => null\n\nexport function Navigate<TGenerics extends PartialGenerics = DefaultGenerics>(\n  options: NavigateOptions<TGenerics>,\n) {\n  let navigate = useNavigate<TGenerics>()\n\n  useLayoutEffect(() => {\n    navigate(options)\n  }, [navigate])\n\n  return null\n}\n\nfunction useBuildNext<TGenerics>() {\n  const location = useLocation<TGenerics>()\n  const router = useRouter<TGenerics>()\n\n  const buildNext = (opts: BuildNextOptions<TGenerics>) => {\n    const next = location.buildNext(router.basepath, opts)\n\n    const matches = matchRoutes<TGenerics>(router, next)\n\n    const __searchFilters = matches\n      .map((match) => match.route.searchFilters ?? [])\n      .flat()\n      .filter(Boolean)\n\n    return location.buildNext(router.basepath, { ...opts, __searchFilters })\n  }\n\n  return useLatestCallback(buildNext)\n}\n\nexport type LinkType<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  props: LinkProps<TGenerics>,\n) => JSX.Element\n\nexport const Link = function Link<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>({\n  to = '.',\n  search,\n  hash,\n  children,\n  target,\n  style = {},\n  replace,\n  onClick,\n  onMouseEnter,\n  className = '',\n  getActiveProps = () => ({}),\n  getInactiveProps = () => ({}),\n  activeOptions,\n  disabled,\n  _ref,\n  ...rest\n}: LinkProps<TGenerics>) {\n  const match = useMatch<TGenerics>()\n  const location = useLocation<TGenerics>()\n  const navigate = useNavigate<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  // If this `to` is a valid external URL, log a warning\n  try {\n    const url = new URL(`${to}`)\n    warning(\n      false,\n      `<Link /> should not be used for external URLs like: ${url.href}`,\n    )\n  } catch (e) {}\n\n  const next = buildNext({\n    to,\n    search,\n    hash,\n    from: { pathname: match.pathname },\n  })\n\n  // The click handler\n  const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {\n    if (onClick) onClick(e)\n\n    if (\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n      // All is well? Navigate!\n      navigate({\n        to,\n        search,\n        hash,\n        replace,\n        from: { pathname: match.pathname },\n      })\n    }\n  }\n\n  // Compare path/hash for matches\n  const pathIsEqual = location.current.pathname === next.pathname\n  const currentPathSplit = location.current.pathname.split('/')\n  const nextPathSplit = next.pathname.split('/')\n  const pathIsFuzzyEqual = nextPathSplit.every(\n    (d, i) => d === currentPathSplit[i],\n  )\n  const hashIsEqual = location.current.hash === next.hash\n\n  // Combine the matches based on user options\n  const pathTest = activeOptions?.exact ? pathIsEqual : pathIsFuzzyEqual\n  const hashTest = activeOptions?.includeHash ? hashIsEqual : true\n\n  // The final \"active\" test\n  const isActive = pathTest && hashTest\n\n  // Get the active props\n  const {\n    style: activeStyle = {},\n    className: activeClassName = '',\n    ...activeRest\n  } = isActive ? getActiveProps() : {}\n\n  // Get the inactive props\n  const {\n    style: inactiveStyle = {},\n    className: inactiveClassName = '',\n    ...inactiveRest\n  } = isActive ? {} : getInactiveProps()\n\n  return (\n    <a\n      {...{\n        ref: _ref,\n        href: disabled ? undefined : next.href,\n        onClick: handleClick,\n        target,\n        style: {\n          ...style,\n          ...activeStyle,\n          ...inactiveStyle,\n        },\n        className:\n          [className, activeClassName, inactiveClassName]\n            .filter(Boolean)\n            .join(' ') || undefined,\n        ...(disabled\n          ? {\n              role: 'link',\n              'aria-disabled': true,\n            }\n          : undefined),\n        ...rest,\n        ...activeRest,\n        ...inactiveRest,\n        children:\n          typeof children === 'function' ? children({ isActive }) : children,\n      }}\n    />\n  )\n}\n\nexport function Outlet<TGenerics extends PartialGenerics = DefaultGenerics>() {\n  const router = useRouter<TGenerics>()\n  const [_, ...matches] = useMatches<TGenerics>()\n\n  const match = matches[0]\n\n  if (!match) {\n    return null\n  }\n\n  const matchElement = match.route.element ?? router.defaultElement\n\n  const element = (\n    <MatchesProvider value={matches}>\n      {matchElement ?? <Outlet />}\n    </MatchesProvider>\n  )\n\n  const pendingElement =\n    match.route.pendingElement ?? router.defaultPendingElement\n\n  if (pendingElement) {\n    return <React.Suspense fallback={pendingElement}>{element}</React.Suspense>\n  }\n\n  return element\n}\n\nexport function useResolvePath<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const router = useRouter<TGenerics>()\n  const match = useMatch<TGenerics>()\n\n  return useLatestCallback((path: string) =>\n    resolvePath(router.basepath!, match.pathname!, cleanPath(path)),\n  )\n}\n\nexport type UseSearchType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => Partial<Maybe<TGenerics['Search'], Search<any>>>\n\nexport function useSearch<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  return location.current.search\n}\n\nexport type MatchRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n) => UseGeneric<TGenerics, 'Params'> | undefined\n\nexport function matchRoute<TGenerics extends PartialGenerics = DefaultGenerics>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n): UseGeneric<TGenerics, 'Params'> | undefined {\n  const pathParams = matchByPath(currentLocation, matchLocation)\n  const searchMatched = matchBySearch(currentLocation, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  if (matchLocation.search && !searchMatched) {\n    return\n  }\n\n  return (pathParams ?? {}) as UseGeneric<TGenerics, 'Params'>\n}\n\nexport type UseMatchRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => (\n  matchLocation: MatchLocation<TGenerics>,\n) => Maybe<TGenerics['Params'], Params<any>> | undefined\n\nexport function useMatchRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): (\n  matchLocation: MatchLocation<TGenerics>,\n  opts?: { caseSensitive?: boolean },\n) => Maybe<TGenerics['Params'], Params<any>> | undefined {\n  const router = useRouter<TGenerics>()\n  const resolvePath = useResolvePath<TGenerics>()\n\n  return useLatestCallback(\n    (matchLocation: MatchLocation<TGenerics> & { pending?: boolean }) => {\n      matchLocation = {\n        ...matchLocation,\n        to: matchLocation.to ? resolvePath(`${matchLocation.to}`) : undefined,\n      }\n\n      return matchRoute(router.state.location, matchLocation)\n    },\n  )\n}\n\nexport function MatchRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>({\n  children,\n  ...rest\n}: MatchLocation<TGenerics> & {\n  children:\n    | React.ReactNode\n    | ((isNextLocation?: Params<TGenerics>) => React.ReactNode)\n}) {\n  const matchRoute = useMatchRoute<TGenerics>()\n  const match = matchRoute(rest)\n\n  if (typeof children === 'function') {\n    return children(match as any)\n  }\n\n  return match ? children : null\n}\n\nexport function usePrompt(message: string, when: boolean | any): void {\n  const location = useLocation()\n\n  React.useEffect(() => {\n    if (!when) return\n\n    let unblock = location.history.block((transition) => {\n      if (window.confirm(message)) {\n        unblock()\n        transition.retry()\n      } else {\n        location.current.pathname = window.location.pathname\n      }\n    })\n\n    return unblock\n  }, [when, location, message])\n}\n\nexport function Prompt({ message, when, children }: PromptProps) {\n  usePrompt(message, when ?? true)\n  return (children ?? null) as React.ReactNode\n}\n\nfunction warning(cond: boolean, message: string) {\n  if (!cond) {\n    if (typeof console !== 'undefined') console.warn(message)\n\n    try {\n      throw new Error(message)\n    } catch {}\n  }\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater?: Updater<TResult>,\n  previous?: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nfunction joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return `${path}`.replace(/\\/{2,}/g, '/')\n}\n\nexport function matchByPath<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n): UseGeneric<TGenerics, 'Params'> | undefined {\n  const baseSegments = parsePathname(currentLocation.pathname)\n  const routeSegments = parsePathname(`${matchLocation.to ?? '*'}`)\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          params[routeSegment.value.substring(1)] = baseSegment.value\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as UseGeneric<TGenerics, 'Params'>) : undefined\n}\n\nfunction matchBySearch<TGenerics extends PartialGenerics = DefaultGenerics>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n) {\n  return !!(\n    matchLocation.search && matchLocation.search(currentLocation.search)\n  )\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part.startsWith('*')) {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === ':') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nfunction isCtrlEvent(e: React.MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nfunction useLatestCallback<TCallback extends (...args: any[]) => any>(\n  cb: TCallback,\n) {\n  const stableFnRef =\n    React.useRef<(...args: Parameters<TCallback>) => ReturnType<TCallback>>()\n  const cbRef = React.useRef<TCallback>(cb)\n\n  cbRef.current = cb\n\n  if (!stableFnRef.current) {\n    stableFnRef.current = (...args) => cbRef.current(...args)\n  }\n\n  return stableFnRef.current\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nfunction replaceEqualDeep(prev: any, next: any) {\n  if (prev === next) {\n    return prev\n  }\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const aSize = array ? prev.length : Object.keys(prev).length\n    const bItems = array ? next : Object.keys(next)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function defaultStringifySearch(search: Record<string, unknown>) {\n  search = { ...search }\n\n  if (search) {\n    Object.keys(search).forEach((key) => {\n      const val = search[key]\n      if (typeof val === 'undefined' || val === undefined) {\n        delete search[key]\n      } else if (val && typeof val === 'object' && val !== null) {\n        try {\n          search[key] = JSON.stringify(val)\n        } catch (err) {\n          // silent\n        }\n      }\n    })\n  }\n\n  const searchStr = new URLSearchParams(\n    search as Record<string, string>,\n  ).toString()\n\n  return searchStr ? `?${searchStr}` : ''\n}\n\nexport function defaultParseSearch(searchStr: string): Record<string, any> {\n  if (searchStr.substring(0, 1) === '?') {\n    searchStr = searchStr.substring(1)\n  }\n\n  let query: Record<string, unknown> = Object.fromEntries(\n    (new URLSearchParams(searchStr) as any).entries(),\n  )\n\n  // Try to parse query params\n  for (let key in query) {\n    const value = query[key]\n\n    try {\n      query[key] = JSON.parse(value as string)\n    } catch (err) {\n      //\n    }\n  }\n\n  return query\n}\n"],"names":["LocationContext","React","createContext","MatchesContext","routerContext","isDOM","Boolean","window","document","createElement","useLayoutEffect","useEffect","ReactLocation","options","listeners","isTransitioning","history","createBrowserHistory","createMemoryHistory","stringifySearch","defaultStringifySearch","parseSearch","defaultParseSearch","current","this","parseLocation","location","destroy","listen","event","_this","notify","subscribe","listener","push","_this2","filter","x","forEach","buildNext","basepath","dest","from","pathname","resolvePath","to","updatedSearch","search","functionalUpdate","filteredSearch","__searchFilters","length","reduce","prev","next","replaceEqualDeep","searchStr","hash","href","key","navigate","replace","navigateTimeout","clearTimeout","nextAction","previousLocation","parsedSearch","split","reverse","MatchesProvider","props","Provider","useLocation","context","useContext","warning","useRouter","value","Error","matchRoutes","router","currentLocation","routes","matches","recurse","parentMatch","params","route","filterRoutes","find","fullRoutePathName","joinPaths","path","fuzzy","children","_route$children2","matchParams","matchRoute","caseSensitive","interpolatedPath","interpolatePath","match","id","_route$children3","rootMatch","leaveWildcard","parsePathname","map","segment","type","substring","useMatches","useMatch","_useMatches","useNavigate","useBuildNext","useLatestCallback","fromCurrent","opts","searchFilters","flat","Outlet","matchElement","element","defaultElement","pendingElement","defaultPendingElement","Suspense","fallback","useResolvePath","cleanPath","matchLocation","pathParams","matchByPath","searchMatched","matchBySearch","useMatchRoute","undefined","state","usePrompt","message","when","unblock","block","transition","confirm","retry","cond","console","warn","updater","previous","paths","join","baseSegments","routeSegments","i","Math","max","baseSegment","routeSegment","isLastRouteSegment","isLastBaseSegment","slice","d","toLowerCase","segments","part","startsWith","charAt","base","RegExp","toSegments","toSegment","index","pop","cb","stableFnRef","useRef","cbRef","array","Array","isArray","isPlainObject","aSize","Object","keys","bItems","bSize","copy","equalItems","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","val","JSON","stringify","err","URLSearchParams","query","fromEntries","entries","parse","target","style","onClick","onMouseEnter","className","getActiveProps","getInactiveProps","activeOptions","disabled","_ref","rest","URL","e","pathIsEqual","currentPathSplit","pathIsFuzzyEqual","every","hashIsEqual","pathTest","exact","hashTest","includeHash","isActive","activeStyle","activeClassName","activeRest","inactiveStyle","inactiveClassName","inactiveRest","ref","metaKey","altKey","ctrlKey","shiftKey","isCtrlEvent","defaultPrevented","button","preventDefault","role","userBasepath","useState","routerState","setRouterState","useMemo","routesById","recurseRoutes","parent","log","update","findIndex"],"mappings":";;;;;;;;;;guCAgNMA,EAAkBC,EAAMC,cAC5B,MAEIC,EAAiBF,EAAMC,cAAiC,MACxDE,EAAgBH,EAAMC,cAE1B,MAGIG,EAAQC,QACM,oBAAXC,QACLA,OAAOC,UACPD,OAAOC,SAASC,eAGdC,EAAkBL,EAAQJ,EAAMS,gBAAkBT,EAAMU,UAMjDC,wBAiBCC,uBAHZC,UAAwB,QACxBC,iBAA2B,OAGpBC,eAAUH,SAAAA,EAASG,WApB1BX,EAAQY,yBAAyBC,8BAqB1BC,+BAAkBN,SAAAA,EAASM,mBAAmBC,OAC9CC,2BAAcR,SAAAA,EAASQ,eAAeC,OAEtCC,QAAUC,KAAKC,cAAcD,KAAKR,QAAQU,eAE1CC,QAAUH,KAAKR,QAAQY,QAAO,SAACC,GAClCC,EAAKP,QAAUO,EAAKL,cAAcI,EAAMH,SAAUI,EAAKP,SACvDO,EAAKC,uCAITC,UAAA,SAAUC,0BACHnB,UAAUoB,KAAKD,GAEb,WACLE,EAAKrB,UAAYqB,EAAKrB,UAAUsB,QAAO,SAACC,UAAMA,IAAMJ,SAIxDF,OAAA,gBACOjB,UAAUwB,SAAQ,SAACL,UAAaA,UAGvCM,UAAA,SACEC,EACAC,sBADAD,IAAAA,EAAmB,cACnBC,IAAAA,EAAoC,QAE9BC,OACDlB,KAAKD,QACLkB,EAAKC,MAGJC,EAAWC,EAAYJ,EAAUE,EAAKC,sBAAaF,EAAKI,MAAM,MAE9DC,YACa,IAAhBL,EAAKM,OACFL,EAAKK,OACLC,EAAiBP,EAAKM,OAAQL,EAAKK,WAAY,GAE/CE,WAAiBR,EAAKS,oBAAiBC,OACzCV,EAAKS,gBAAgBE,QACnB,SAACC,EAAMC,UAASA,EAAKD,EAAMP,KAC3BJ,EAAKK,QAEPD,EAEEC,EAASQ,EAAiBb,EAAKK,OAAQE,GAEvCO,EAAYhC,KAAKL,gBAAgB4B,GACnCU,EAAOT,EAAiBP,EAAKgB,KAAMf,EAAKe,YAGrC,CACLd,SAAAA,EACAI,OAAAA,EACAS,UAAAA,EACAC,KANFA,EAAOA,MAAWA,EAAS,GAOzBC,QAASf,EAAWa,EAAYC,EAChCE,IAAKlB,EAAKkB,QAIdC,SAAA,SAASN,EAA2BO,QAC7BtC,QAAU+B,EAEX9B,KAAKsC,iBAAiBC,aAAavC,KAAKsC,qBAExCE,EAAiC,iBAEhCH,IACHG,EAAa,QAIbxC,KAAKC,cAAcD,KAAKR,QAAQU,UAAUgC,OAASlC,KAAKD,QAAQmC,OAEhDlC,KAAKD,QAAQoC,MAC7BK,EAAa,WAGI,YAAfA,EACKxC,KAAKR,QAAQ6C,QAAQ,CAC1BlB,SAAUnB,KAAKD,QAAQoB,SACvBc,KAAMjC,KAAKD,QAAQkC,KACnBV,OAAQvB,KAAKD,QAAQiC,YAIlBhC,KAAKR,QAAQkB,KAAK,CACvBS,SAAUnB,KAAKD,QAAQoB,SACvBc,KAAMjC,KAAKD,QAAQkC,KACnBV,OAAQvB,KAAKD,QAAQiC,eAKzB/B,cAAA,SACEC,EACAuC,SAEMC,EAAe1C,KAAKH,YAAYK,EAASqB,cAExC,CACLJ,SAAUjB,EAASiB,SACnBa,UAAW9B,EAASqB,OACpBA,OAAQQ,QAAiBU,SAAAA,EAAkBlB,OAAQmB,GACnDT,cAAM/B,EAAS+B,KAAKU,MAAM,KAAKC,UAAU,MAAM,GAC/CV,QAAShC,EAASiB,SAAWjB,EAASqB,OAASrB,EAAS+B,KACxDE,IAAKjC,EAASiC,WAUb,SAASU,EACdC,UAEOrE,gBAACE,EAAeoE,SAAaD,GAmI/B,SAASE,QAGRC,EAAUxE,EAAMyE,WAAW1E,UAGjC2E,IAAUF,EAAS,uDAEZA,EAAQ/C,SAcV,SAASkD,QAGRC,EAAQ5E,EAAMyE,WAAWtE,OAC1ByE,QACHF,GAAQ,EAAM,+DACR,IAAIG,aAGLD,EAUF,SAASE,EAGdC,EACAC,OAEKD,EAAOE,OAAO/B,aACV,OAGHgC,EAAmC,UAEzB,SAAVC,EACJF,EACAG,SAEM1C,EAAqB0C,EAArB1C,SAAU2C,EAAWD,EAAXC,OAKVC,SAJiBP,GAAAA,EAAQQ,mBAC3BR,SAAAA,EAAQQ,aAAaN,GACrBA,GAEyBO,MAAK,SAACF,WAC3BG,EAAoBC,EAAU,CAAChD,EAAU4C,EAAMK,OAE/CC,KAA0B,MAAfN,EAAMK,eAAgBL,EAAMO,WAANC,EAAgB5C,QAEjD6C,EAAcC,EAAWhB,EAAiB,CAC9CpC,GAAI6C,EACJ3C,OAAQwC,EAAMxC,OACd8C,MAAAA,EACAK,uBAAeX,EAAMW,iBAAiBlB,EAAOkB,uBAG3CF,IACFV,OACKA,EACAU,MAIEA,QAGNT,OAICY,EAAmBC,EAAgBb,EAAMK,KAAMN,GACrD3C,EAAWgD,EAAU,CAAChD,EAAUwD,QAI1BE,EAA+B,CACnCC,GAHqBF,EAAgBb,EAAMe,GAAIhB,GAAQ,GAIvDC,MAAAA,EACAD,OAAAA,EACA3C,SAAAA,EACAI,OAAQkC,EAAgBlC,QAG1BoC,EAAQjD,KAAKmE,YAETd,EAAMO,WAANS,EAAgBpD,QAClBiC,EAAQG,EAAMO,SAAUO,IAI5BjB,CAAQJ,EAAOE,OAAQF,EAAOwB,WAEvBrB,EAGT,SAASiB,EACPR,EACAN,EACAmB,UAIOd,EAF0Be,EAAcd,GAGpBe,KAAI,SAACC,SACN,MAAlBA,EAAQ/B,OAAkB4B,EAIT,UAAjBG,EAAQC,cACHvB,EAAQsB,EAAQ/B,MAAMiC,UAAU,OAAO,GAGzCF,EAAQ/B,MAPN,aA2BR,SAASkC,WAGP9G,EAAMyE,WAAWvE,GAMnB,SAAS6G,0BAGPD,YAAAE,EAA0B,GAO5B,SAASC,QAGRxF,EAAW8C,IACX6B,EAAQW,IACRzE,EAAY4E,WA0BXC,qBAvBLrE,IAAAA,OACAU,IAAAA,KACAI,IAAAA,QACAnB,IAAAA,KACAG,IAAAA,GACAwE,IAAAA,YAIAA,WAAcA,UAA6B,IAAPxE,MAE9BS,EAAOf,EAAU,CACrBM,GAAAA,EACAE,OAAAA,EACAU,KAAAA,EACAf,KAAM2E,EACF3F,EAASH,cACTmB,EAAAA,EAAQ,CAAEC,SAAU0D,EAAM1D,YAGhCjB,EAASkC,SAASN,EAAMO,MAqB5B,SAASsD,QACDzF,EAAW8C,IACXQ,EAASJ,WAeRwC,GAbW,SAACE,OACXhE,EAAO5B,EAASa,UAAUyC,EAAOxC,SAAU8E,GAI3CpE,EAFU6B,EAAuBC,EAAQ1B,GAG5CqD,KAAI,SAACN,yBAAUA,EAAMd,MAAMgC,iBAAiB,MAC5CC,OACApF,OAAO9B,gBAEHoB,EAASa,UAAUyC,EAAOxC,cAAe8E,GAAMpE,gBAAAA,QAuInD,SAASuE,YACRzC,EAASJ,MACSmC,aAAX5B,aAEPkB,EAAQlB,EAAQ,OAEjBkB,SACI,SAGHqB,WAAerB,EAAMd,MAAMoC,WAAW3C,EAAO4C,eAE7CD,EACJ1H,gBAACoE,GAAgBQ,MAAOM,SACrBuC,EAAAA,EAAgBzH,gBAACwH,SAIhBI,WACJxB,EAAMd,MAAMsC,kBAAkB7C,EAAO8C,6BAEnCD,EACK5H,gBAACA,EAAM8H,UAASC,SAAUH,GAAiBF,GAG7CA,EAGF,SAASM,QAGRjD,EAASJ,IACTyB,EAAQW,WAEPI,GAAkB,SAACxB,UACxBhD,EAAYoC,EAAOxC,SAAW6D,EAAM1D,SAAWuF,EAAUtC,OAqBtD,SAASK,EACdhB,EACAkD,OAEMC,EAAaC,EAAYpD,EAAiBkD,GAC1CG,EA4LR,SACErD,EACAkD,YAGEA,EAAcpF,SAAUoF,EAAcpF,OAAOkC,EAAgBlC,SAjMzCwF,CAActD,EAAiBkD,QAEjDA,EAActF,IAAOuF,MAIrBD,EAAcpF,QAAWuF,gBAIrBF,EAAAA,EAAc,GASjB,SAASI,QAMRxD,EAASJ,IACThC,EAAcqF,WAEbb,GACL,SAACe,UACCA,OACKA,GACHtF,GAAIsF,EAActF,GAAKD,KAAeuF,EAActF,SAAQ4F,IAGvDxC,EAAWjB,EAAO0D,MAAMhH,SAAUyG,MAyBxC,SAASQ,EAAUC,EAAiBC,OACnCnH,EAAW8C,IAEjBvE,EAAMU,WAAU,cACTkI,OAEDC,EAAUpH,EAASV,QAAQ+H,OAAM,SAACC,GAChCzI,OAAO0I,QAAQL,IACjBE,IACAE,EAAWE,SAEXxH,EAASH,QAAQoB,SAAWpC,OAAOmB,SAASiB,mBAIzCmG,KACN,CAACD,EAAMnH,EAAUkH,IAQtB,SAASjE,EAAQwE,EAAeP,OACzBO,EAAM,CACc,oBAAZC,SAAyBA,QAAQC,KAAKT,aAGzC,IAAI9D,MAAM8D,GAChB,YAQC,SAAS5F,EACdsG,EACAC,SALoB,mBAOLD,EACNA,EAAQC,GAGVD,EAGT,SAAS3D,EAAU6D,UACVtB,EAAUsB,EAAMpH,OAAO9B,SAASmJ,KAAK,MAGvC,SAASvB,EAAUtC,aAEdA,GAAO/B,QAAQ,UAAW,KAG/B,SAASwE,EAGdpD,EACAkD,SAEMuB,EAAehD,EAAczB,EAAgBtC,UAC7CgH,EAAgBjD,eAAiByB,EAActF,MAAM,MAErDyC,EAAiC,UAExB,eAEX,IAAIsE,EAAI,EACRA,EAAIC,KAAKC,IAAIJ,EAAavG,OAAQwG,EAAcxG,QAChDyG,IACA,KACMG,EAAcL,EAAaE,GAC3BI,EAAeL,EAAcC,GAE7BK,EAAqBL,IAAMD,EAAcxG,OAAS,EAClD+G,EAAoBN,IAAMF,EAAavG,OAAS,KAElD6G,EAAc,IACU,aAAtBA,EAAanD,mBACXkD,IAAAA,EAAalF,SACfS,EAAO,KAAOK,EAAU+D,EAAaS,MAAMP,GAAGjD,KAAI,SAACyD,UAAMA,EAAEvF,WACpD,MAKe,aAAtBmF,EAAanD,KAAqB,IACT,MAAvBmD,EAAanF,cAAkBkF,IAAAA,EAAalF,cACvC,KAGLkF,KACE5B,EAAcjC,kBACZ8D,EAAanF,QAAUkF,EAAYlF,aAC9B,OAEJ,GACLmF,EAAanF,MAAMwF,gBACnBN,EAAYlF,MAAMwF,qBAEX,MAKRN,SACI,EAGiB,UAAtBC,EAAanD,OACfvB,EAAO0E,EAAanF,MAAMiC,UAAU,IAAMiD,EAAYlF,UAItDoF,IAAuBC,UAChB/B,EAActC,aAGpB,EArDM,GAwDGP,OAA6CmD,EAY1D,SAAS/B,EAAc/D,OACvBA,QACI,OAKH2H,EAAsB,MAEC,OAJ7B3H,EAAWuF,EAAUvF,IAIRwH,MAAM,EAAG,KACpBxH,EAAWA,EAASmE,UAAU,GAC9BwD,EAASpI,KAAK,CACZ2E,KAAM,WACNhC,MAAO,QAINlC,SACI2H,MAIHnG,EAAQxB,EAASwB,MAAM,KAAK/B,OAAO9B,gBAEzCgK,EAASpI,WAAToI,EACKnG,EAAMwC,KAAI,SAAC4D,UACRA,EAAKC,WAAW,KACX,CACL3D,KAAM,WACNhC,MAAO0F,GAIY,MAAnBA,EAAKE,OAAO,GACP,CACL5D,KAAM,QACNhC,MAAO0F,GAIJ,CACL1D,KAAM,WACNhC,MAAO0F,OAKc,MAAvB5H,EAASwH,OAAO,KAClBxH,EAAWA,EAASmE,UAAU,GAC9BwD,EAASpI,KAAK,CACZ2E,KAAM,WACNhC,MAAO,OAIJyF,EAGF,SAAS1H,EAAYJ,EAAkBkI,EAAc7H,GAC1D6H,EAAOA,EAAK7G,QAAQ,IAAI8G,WAAWnI,GAAa,KAChDK,EAAKA,EAAGgB,QAAQ,IAAI8G,WAAWnI,GAAa,SAExCkH,EAAehD,EAAcgE,GAC3BE,EAAalE,EAAc7D,UAEjC+H,EAAWtI,SAAQ,SAACuI,EAAWC,MACL,MAApBD,EAAUhG,MACPiG,EAGMA,IAAUF,EAAWzH,OAAS,GAEvCuG,EAAaxH,KAAK2I,GAHlBnB,EAAe,CAACmB,QAOb,GAAwB,OAApBA,EAAUhG,MACnB6E,EAAaqB,UACR,CAAA,GAAwB,MAApBF,EAAUhG,aAGnB6E,EAAaxH,KAAK2I,OAMf3C,EAFQvC,GAAWnD,UAAakH,EAAa/C,KAAI,SAACyD,UAAMA,EAAEvF,YASnE,SAASuC,EACP4D,OAEMC,EACJhL,EAAMiL,SACFC,EAAQlL,EAAMiL,OAAkBF,UAEtCG,EAAM5J,QAAUyJ,EAEXC,EAAY1J,UACf0J,EAAY1J,QAAU,kBAAa4J,EAAM5J,cAAN4J,eAG9BF,EAAY1J,QAQrB,SAASgC,EAAiBF,EAAWC,MAC/BD,IAASC,SACJD,MAGH+H,EAAQC,MAAMC,QAAQjI,IAASgI,MAAMC,QAAQhI,MAE/C8H,GAAUG,EAAclI,IAASkI,EAAcjI,GAAQ,SACnDkI,EAAQJ,EAAQ/H,EAAKF,OAASsI,OAAOC,KAAKrI,GAAMF,OAChDwI,EAASP,EAAQ9H,EAAOmI,OAAOC,KAAKpI,GACpCsI,EAAQD,EAAOxI,OACf0I,EAAYT,EAAQ,GAAK,GAE3BU,EAAa,EAERlC,EAAI,EAAGA,EAAIgC,EAAOhC,IAAK,KACxBjG,EAAMyH,EAAQxB,EAAI+B,EAAO/B,GAC/BiC,EAAKlI,GAAOJ,EAAiBF,EAAKM,GAAML,EAAKK,IACzCkI,EAAKlI,KAASN,EAAKM,IACrBmI,WAIGN,IAAUI,GAASE,IAAeN,EAAQnI,EAAOwI,SAGnDvI,EAIT,SAASiI,EAAcQ,OAChBC,EAAmBD,UACf,MAIHE,EAAOF,EAAEG,oBACK,IAATD,SACF,MAIHE,EAAOF,EAAKG,kBACbJ,EAAmBG,MAKnBA,EAAKE,eAAe,iBAQ3B,SAASL,EAAmBD,SACmB,oBAAtCN,OAAOW,UAAUE,SAASC,KAAKR,GAGjC,SAAS3K,EAAuB2B,IACrCA,OAAcA,KAGZ0I,OAAOC,KAAK3I,GAAQT,SAAQ,SAACqB,OACrB6I,EAAMzJ,EAAOY,WACA,IAAR6I,QAA+B/D,IAAR+D,SACzBzJ,EAAOY,QACT,GAAI6I,GAAsB,iBAARA,GAA4B,OAARA,MAEzCzJ,EAAOY,GAAO8I,KAAKC,UAAUF,GAC7B,MAAOG,YAOTnJ,EAAY,IAAIoJ,gBACpB7J,GACAuJ,kBAEK9I,MAAgBA,EAAc,GAGhC,SAASlC,EAAmBkC,GACC,MAA9BA,EAAUsD,UAAU,EAAG,KACzBtD,EAAYA,EAAUsD,UAAU,QAG9B+F,EAAiCpB,OAAOqB,YACzC,IAAIF,gBAAgBpJ,GAAmBuJ,eAIrC,IAAIpJ,KAAOkJ,EAAO,KACfhI,EAAQgI,EAAMlJ,OAGlBkJ,EAAMlJ,GAAO8I,KAAKO,MAAMnI,GACxB,MAAO8H,YAKJE,2UA3lBW,oBAGlBhK,GAAAA,aAAK,MACLE,IAAAA,OACAU,IAAAA,KACAqC,IAAAA,SACAmH,IAAAA,WACAC,MAAAA,aAAQ,KACRrJ,IAAAA,QACAsJ,IAAAA,UACAC,qBACAC,UAAAA,aAAY,SACZC,eAAAA,aAAiB,iBAAO,UACxBC,iBAAAA,aAAmB,iBAAO,MAC1BC,IAAAA,cACAC,IAAAA,SACAC,IAAAA,KACGC,SAEGtH,EAAQW,IACRtF,EAAW8C,IACXZ,EAAWsD,IACX3E,EAAY4E,QAKhBxC,GACE,yDAFU,IAAIiJ,OAAO/K,GAGsCa,MAE7D,MAAOmK,QAEHvK,EAAOf,EAAU,CACrBM,GAAAA,EACAE,OAAAA,EACAU,KAAAA,EACAf,KAAM,CAAEC,SAAU0D,EAAM1D,YA0BpBmL,EAAcpM,EAASH,QAAQoB,WAAaW,EAAKX,SACjDoL,EAAmBrM,EAASH,QAAQoB,SAASwB,MAAM,KAEnD6J,EADgB1K,EAAKX,SAASwB,MAAM,KACH8J,OACrC,SAAC7D,EAAGR,UAAMQ,IAAM2D,EAAiBnE,MAE7BsE,EAAcxM,EAASH,QAAQkC,OAASH,EAAKG,KAG7C0K,QAAWX,GAAAA,EAAeY,MAAQN,EAAcE,EAChDK,QAAWb,IAAAA,EAAec,aAAcJ,EAGxCK,EAAWJ,GAAYE,IAOzBE,EAAWjB,IAAmB,OAHhCJ,MAAOsB,aAAc,SACrBnB,UAAWoB,aAAkB,KAC1BC,WAQDH,EAAW,GAAKhB,QAHlBL,MAAOyB,aAAgB,SACvBtB,UAAWuB,cAAoB,KAC5BC,iBAIH5O,uBAEI6O,IAAKpB,EACLhK,KAAM+J,OAAWhF,EAAYnF,EAAKI,KAClCyJ,QAxDc,SAACU,GACfV,GAASA,EAAQU,GA8azB,SAAqBA,YACTA,EAAEkB,SAAWlB,EAAEmB,QAAUnB,EAAEoB,SAAWpB,EAAEqB,UA5a7CC,CAAYtB,IACZA,EAAEuB,kBACDnC,GAAqB,UAAXA,GACC,IAAbY,EAAEwB,SAEFxB,EAAEyB,iBAEF1L,EAAS,CACPf,GAAAA,EACAE,OAAAA,EACAU,KAAAA,EACAI,QAAAA,EACAnB,KAAM,CAAEC,SAAU0D,EAAM1D,cAyCxBsK,OAAAA,EACAC,WACKA,EACAsB,EACAG,GAELtB,UACE,CAACA,EAAWoB,EAAiBG,IAC1BxM,OAAO9B,SACPmJ,KAAK,WAAQhB,GACdgF,EACA,CACE8B,KAAM,wBACW,QAEnB9G,EACDkF,EACAe,EACAG,IACH/I,SACsB,mBAAbA,EAA0BA,EAAS,CAAEyI,SAAAA,IAAczI,mBA2G7D,gBAGLA,IAAAA,SACG6H,SAOGtH,EADamC,GACLvC,CAAW0H,SAED,mBAAb7H,EACFA,EAASO,GAGXA,EAAQP,EAAW,qCAvRrB,SACLjF,OAEI+C,EAAWsD,WAEfxG,GAAgB,WACdkD,EAAS/C,KACR,CAAC+C,IAEG,0BAoSF,gBAAkBgF,IAAAA,QAASC,IAAAA,KAAM/C,IAAAA,gBACtC6C,EAAUC,QAASC,GAAAA,SACX/C,EAAAA,EAAY,iCAhnBf,gBACLA,IAAAA,SACApE,IAAAA,SACAwD,IAAAA,OACUsK,IAAVhN,SAEGmL,SAEGnL,EAAW0F,aAAcsH,EAAAA,EAAgB,OAETvP,EAAMwP,SAE1C,CACA/N,SAAUA,EAASH,QACnB4D,QAAS,KAJJuK,OAAaC,OAOdnJ,EAAYvG,EAAM2P,SACtB,iBAAO,CACLtJ,GAAI,OACJhB,OAAQ,GACRvC,OAAQ,GACRJ,SAAUH,EACV+C,MAAO,QAET,CAAC/C,IAGGwC,EAAoC/E,EAAM2P,SAAQ,eAChDC,EAAsD,UAwC5D3K,EAtCsB,SAAhB4K,EACJ5K,EACA6K,UAEO7K,EAAOyB,KAAI,SAACpB,WACXK,WAAOL,EAAMK,QAAQ,IAErBU,EAAKX,EAAU,CACJ,gBAAfoK,SAAAA,EAAQzJ,IAAgB,SAAKyJ,SAAAA,EAAQzJ,UAClCV,SAAAA,EAAM/B,QAAQ,SAAU,QAAQ0B,EAAMe,OAASf,EAAMe,GAAO,SAGjEf,OACKA,GACHe,GAAAA,IAGEuJ,EAAWvJ,SAQP,IAAIxB,aAGZ+K,EAAWvJ,GAAMf,EAEjBA,EAAMO,kBAAWP,EAAMO,aAAU3C,OAC7B2M,EAAcvK,EAAMO,SAAUP,QAC9BkD,EAEGlD,KAIFuK,CAAc5K,QAGlByI,GACHkC,WAAAA,EACA3K,OAAAA,EACA1C,SAAAA,EACAgE,UAAAA,EACAkC,MAAOgH,MAER,CAACA,EAAalJ,EAAWhE,WAE5B4G,QAAQ4G,IAAIhL,EAAO0D,OAEnBhI,GAAgB,eACRuP,EAAS,eACP9K,EAAUJ,EAAYC,EAAQtD,EAASH,SAE7CoO,GAAe,iBACN,CACLjO,SAAUA,EAASH,QACnB4D,QAASA,cAKf8K,IAEOvO,EAASM,UAAUiO,KACzB,CAACvO,EAASH,QAAQoC,MAGnB1D,gBAACD,EAAgBuE,UAASM,MAAO,CAAEnD,SAAAA,IACjCzB,gBAACG,EAAcmE,UAASM,MAAOG,GAC7B/E,gBAACoE,GAAgBQ,OAAQG,EAAOwB,kBAAexB,EAAO0D,MAAMvD,gBACzDW,EAAAA,EAAY7F,gBAACwH,mRAsJjB,eAGCzC,EAASJ,IACTyB,EAAQW,IAER7B,EAAUH,EAAO0D,MAAMvD,eAEtBA,EAAQgF,MAAM,EAAGhF,EAAQ+K,WAAU,SAAC9F,UAAMA,EAAE9D,KAAOD,EAAMC,MAAM,+DAsQjE,kBAGY9B,IACDjD,QAAQwB"}