{"version":3,"file":"index.js","sources":["../../src/index.tsx"],"sourcesContent":["import {\n  Route,\n  parsePathname,\n  PartialGenerics,\n  DefaultGenerics,\n} from '@tanstack/react-location'\n\nexport function rankRoutes<TGenerics extends PartialGenerics = DefaultGenerics>(\n  routes: Route<TGenerics>[],\n): Route<TGenerics>[] {\n  return [...routes]\n    .map((d, i) => {\n      return { ...d, index: i }\n    })\n    .sort((a, b) => {\n      if (a.search || b.search) {\n        if (!b.search) {\n          return -1\n        }\n        if (!a.search) {\n          return 1\n        }\n      }\n\n      const aSegments = parsePathname(a.path)\n      const bSegments = parsePathname(b.path)\n\n      // Multi-sort by each segment\n      for (let i = 0; i < aSegments.length; i++) {\n        const aSegment = aSegments[i]\n        const bSegment = bSegments[i]\n\n        if (aSegment && bSegment) {\n          let sort: -1 | 1 | 0 = 0\n          ;(\n            [\n              {\n                key: 'value',\n                value: '*',\n              },\n              {\n                key: 'value',\n                value: '/',\n              },\n              {\n                key: 'type',\n                value: 'param',\n              },\n            ] as const\n          ).some((condition) => {\n            if (\n              [aSegment[condition.key], bSegment[condition.key]].includes(\n                condition.value,\n              ) &&\n              aSegment[condition.key] !== bSegment[condition.key]\n            ) {\n              sort = aSegment[condition.key] === condition.value ? 1 : -1\n              return true\n            }\n\n            return false\n          })\n\n          if (sort !== 0) {\n            return sort\n          }\n        } else {\n          // Then shorter segments last\n          return aSegment ? -1 : 1\n        }\n      }\n\n      // Keep things stable by route index\n      return a.index - b.index\n    })\n}\n"],"names":["rankRoutes","routes","map","d","i","index","sort","a","b","search","aSegments","parsePathname","path","bSegments","aSegment","bSegment","key","value","some","condition","includes","length"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOO,SAASA,UAAT,CACLC,MADK,EAEe;AACpB,SAAO,UAAIA,MAAJ,EACJC,GADI,CACA,UAACC,CAAD,EAAIC,CAAJ,EAAU;AACb,wBAAYD,CAAZ;AAAeE,MAAAA,KAAK,EAAED;AAAtB;AACD,GAHI,EAIJE,IAJI,CAIC,UAACC,CAAD,EAAIC,CAAJ,EAAU;AACd,QAAID,CAAC,CAACE,MAAF,IAAYD,CAAC,CAACC,MAAlB,EAA0B;AACxB,UAAI,CAACD,CAAC,CAACC,MAAP,EAAe;AACb,eAAO,CAAC,CAAR;AACD;;AACD,UAAI,CAACF,CAAC,CAACE,MAAP,EAAe;AACb,eAAO,CAAP;AACD;AACF;;AAED,QAAMC,SAAS,GAAGC,aAAa,CAACJ,CAAC,CAACK,IAAH,CAA/B;AACA,QAAMC,SAAS,GAAGF,aAAa,CAACH,CAAC,CAACI,IAAH,CAA/B,CAXc;;AAAA,+BAcLR,CAdK;AAeZ,UAAMU,QAAQ,GAAGJ,SAAS,CAACN,CAAD,CAA1B;AACA,UAAMW,QAAQ,GAAGF,SAAS,CAACT,CAAD,CAA1B;;AAEA,UAAIU,QAAQ,IAAIC,QAAhB,EAA0B;AACxB,YAAIT,IAAgB,GAAG,CAAvB;AAEE,SACE;AACEU,UAAAA,GAAG,EAAE,OADP;AAEEC,UAAAA,KAAK,EAAE;AAFT,SADF,EAKE;AACED,UAAAA,GAAG,EAAE,OADP;AAEEC,UAAAA,KAAK,EAAE;AAFT,SALF,EASE;AACED,UAAAA,GAAG,EAAE,MADP;AAEEC,UAAAA,KAAK,EAAE;AAFT,SATF,CADD,CAeCC,IAfD,CAeM,UAACC,SAAD,EAAe;AACpB,cACE,CAACL,QAAQ,CAACK,SAAS,CAACH,GAAX,CAAT,EAA0BD,QAAQ,CAACI,SAAS,CAACH,GAAX,CAAlC,EAAmDI,QAAnD,CACED,SAAS,CAACF,KADZ,KAGAH,QAAQ,CAACK,SAAS,CAACH,GAAX,CAAR,KAA4BD,QAAQ,CAACI,SAAS,CAACH,GAAX,CAJtC,EAKE;AACAV,YAAAA,IAAI,GAAGQ,QAAQ,CAACK,SAAS,CAACH,GAAX,CAAR,KAA4BG,SAAS,CAACF,KAAtC,GAA8C,CAA9C,GAAkD,CAAC,CAA1D;AACA,mBAAO,IAAP;AACD;;AAED,iBAAO,KAAP;AACD,SA3BA;;AA6BD,YAAIX,IAAI,KAAK,CAAb,EAAgB;AACd;AAAA,eAAOA;AAAP;AACD;AACF,OAlCD,MAkCO;AACL;AACA;AAAA,aAAOQ,QAAQ,GAAG,CAAC,CAAJ,GAAQ;AAAvB;AACD;AAvDW;;AAcd,SAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,SAAS,CAACW,MAA9B,EAAsCjB,CAAC,EAAvC,EAA2C;AAAA,uBAAlCA,CAAkC;;AAAA;AA0C1C,KAxDa;;;AA2Dd,WAAOG,CAAC,CAACF,KAAF,GAAUG,CAAC,CAACH,KAAnB;AACD,GAhEI,CAAP;AAiED;;;;"}